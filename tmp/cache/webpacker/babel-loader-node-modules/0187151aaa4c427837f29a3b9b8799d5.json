{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _this = this,\n    _jsxFileName = \"/Users/learnacademy/Desktop/CapStoneProject/app/javascript/components/pages/CommentIndex.js\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport React, { useState, useEffect } from \"react\";\nimport CommentEdit from '../partials/commentsPartials/CommentEdit';\nimport CommentNew from '../partials/commentsPartials/CommentNew';\nimport CommentList from '../partials/commentsPartials/CommentList';\nimport { Container, Media, Button, Form, FormGroup, Label, Input, FormText, ListGroup, ListGroupItem, ListGroupItemHeading, ListGroupItemText } from 'reactstrap';\n\nvar Comments = function Comments(props) {\n  // State for a new comment (written in the comment form)\n  var _useState = useState(\"\"),\n      _useState2 = _slicedToArray(_useState, 2),\n      commentEntry = _useState2[0],\n      setCommentEntry = _useState2[1]; // State for existing comment within the editor form\n\n\n  var _useState3 = useState(\"\"),\n      _useState4 = _slicedToArray(_useState3, 2),\n      commentEditEntry = _useState4[0],\n      setCommentEditEntry = _useState4[1]; // Array holding the ID of the comment that is in editor mode. ID gets removed after leaving edidtor mode\n\n\n  var _useState5 = useState([]),\n      _useState6 = _slicedToArray(_useState5, 2),\n      editArray = _useState6[0],\n      setEditArray = _useState6[1]; // Allows only one comment to be in editor mode at a time\n\n\n  var _useState7 = useState(false),\n      _useState8 = _slicedToArray(_useState7, 2),\n      editorOn = _useState8[0],\n      setEditorOn = _useState8[1]; // Array of comment objects fetched from the API\n\n\n  var _useState9 = useState([]),\n      _useState10 = _slicedToArray(_useState9, 2),\n      comments = _useState10[0],\n      setComments = _useState10[1]; // Fetch all trail comments upon render\n\n\n  useEffect(function () {\n    getComments();\n  }, []); // ---------- CODE FOR TYPING/POSTING NEW COMMENT ----------\n  // Set state of commentEntry to whatever the form input is \n\n  var handleChange = function handleChange(e) {\n    setCommentEntry(e.target.value);\n  }; // Only call POST function if comment isn't blank\n\n\n  var handleSubmit = function handleSubmit() {\n    if (commentEntry === \"\") return;else addToComments();\n  }; // Fetch request to POST comment\n\n\n  var addToComments = function addToComments() {\n    fetch(\"/comments\", {\n      // JSON needs to include comment string, trail id, and user name\n      body: JSON.stringify({\n        post: commentEntry,\n        trail_id: props.trail_id,\n        user_name: props.user_name,\n        trail_name: props.trail_name\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      method: \"POST\"\n    }).then(function (response) {\n      if (response.ok) {\n        // If post successful, clear new comment form\n        setCommentEntry(\"\"); // Refetch comments upon adding new comment\n\n        getComments();\n      }\n    })[\"catch\"](function (error) {\n      console.log(\"error:\", error);\n    });\n  }; // ---------- CODE FOR EDITING/UPDATING EXISTING COMMENT ----------\n  // Upon clicking the Edit button, do the following:\n\n\n  var handleEditClick = function handleEditClick(id, body) {\n    // Check that the particular comment's ID is not in the \"editArray\" and editor mode is not open elsewhere\n    if (!editArray.includes(id) && !editorOn) {\n      // Set editor mode to true to prevent other editors from opening\n      setEditorOn(true); // Add comment ID to array\n\n      setEditArray([].concat(_toConsumableArray(editArray), [id])); // Set the comment edit entry to the comment text\n\n      setCommentEditEntry(body);\n    } // \n    else if (editArray.includes(id) && editorOn) {\n        setEditorOn(false);\n        var temp = editArray.filter(function (num) {\n          return num !== id;\n        });\n        setEditArray(temp);\n        setCommentEditEntry(\"\");\n      }\n  }; // Set state of commentEditEntry to \n\n\n  var handleChangeEdit = function handleChangeEdit(e) {\n    setCommentEditEntry(e.target.value);\n  }; //\n\n\n  var updateComment = function updateComment(id, trailId) {\n    fetch(\"/comments/\".concat(id), {\n      body: JSON.stringify({\n        post: commentEditEntry,\n        trail_id: trailId,\n        user_name: props.user_name,\n        trail_name: props.trail_name\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      method: \"PATCH\"\n    }).then(function (response) {\n      if (response.ok) {\n        var temp = editArray.filter(function (num) {\n          return num !== id;\n        });\n        setEditArray(temp);\n        setEditorOn(false);\n        getComments();\n      }\n    })[\"catch\"](function (error) {\n      console.log(\"error:\", error);\n    });\n  }; // ---------- CODE FOR FETCHIING ALL TRAIL COMMENTS ----------\n\n\n  function getComments() {\n    return _getComments.apply(this, arguments);\n  } // ---------- CODE FOR DELETING COMMENT ----------\n\n\n  function _getComments() {\n    _getComments = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var response, data, sortedData;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return fetch('/comments');\n\n            case 3:\n              response = _context.sent;\n              _context.next = 6;\n              return response.json();\n\n            case 6:\n              data = _context.sent;\n\n              if (response.ok) {\n                //check the console to make sure we have all the trails\n                sortedData = data.filter(function (trail) {\n                  return trail.trail_id == props.trail_id;\n                }).sort(function (a, b) {\n                  if (a.updated_at === b.updated_at) return 0;else if (a.updated_at > b.updated_at) return -1;else return 1;\n                }); //populate the newTrails state array with data\n\n                setComments(sortedData);\n                console.log(\"sorted comments data:\", sortedData);\n              }\n\n              _context.next = 13;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](0);\n              console.log(_context.t0);\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 10]]);\n    }));\n    return _getComments.apply(this, arguments);\n  }\n\n  var deleteComment = function deleteComment(id) {\n    fetch(\"/comments/\".concat(id), {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      method: \"DELETE\"\n    }).then(function (response) {\n      if (response.ok) {\n        getComments();\n      }\n    });\n  };\n\n  return /*#__PURE__*/React.createElement(Container, {\n    className: \"comment-index-container\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 151,\n      columnNumber: 3\n    }\n  }, props.logged_in && /*#__PURE__*/React.createElement(CommentNew, {\n    handleSubmit: handleSubmit,\n    commentEntry: commentEntry,\n    handleChange: handleChange,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(CommentList, {\n    comments: comments,\n    commentEditEntry: commentEditEntry,\n    editArray: editArray,\n    user_id: props.user_id,\n    updateComment: updateComment,\n    handleChangeEdit: handleChangeEdit,\n    handleEditClick: handleEditClick,\n    deleteComment: deleteComment,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 7\n    }\n  }));\n};\n\nexport default Comments;","map":{"version":3,"sources":["/Users/learnacademy/Desktop/CapStoneProject/app/javascript/components/pages/CommentIndex.js"],"names":["React","useState","useEffect","CommentEdit","CommentNew","CommentList","Container","Media","Button","Form","FormGroup","Label","Input","FormText","ListGroup","ListGroupItem","ListGroupItemHeading","ListGroupItemText","Comments","props","commentEntry","setCommentEntry","commentEditEntry","setCommentEditEntry","editArray","setEditArray","editorOn","setEditorOn","comments","setComments","getComments","handleChange","e","target","value","handleSubmit","addToComments","fetch","body","JSON","stringify","post","trail_id","user_name","trail_name","headers","method","then","response","ok","error","console","log","handleEditClick","id","includes","temp","filter","num","handleChangeEdit","updateComment","trailId","json","data","sortedData","trail","sort","a","b","updated_at","deleteComment","logged_in","user_id"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\"\nimport CommentEdit from '../partials/commentsPartials/CommentEdit'\nimport CommentNew from '../partials/commentsPartials/CommentNew'\nimport CommentList from '../partials/commentsPartials/CommentList'\nimport { Container, Media, Button, Form, FormGroup, Label, Input, FormText, ListGroup, ListGroupItem, ListGroupItemHeading, ListGroupItemText } from 'reactstrap'\n\nconst Comments = (props) => {\n  // State for a new comment (written in the comment form)\n  const [commentEntry, setCommentEntry] = useState(\"\")\n  // State for existing comment within the editor form\n  const [commentEditEntry, setCommentEditEntry] = useState(\"\")\n  // Array holding the ID of the comment that is in editor mode. ID gets removed after leaving edidtor mode\n  const [editArray, setEditArray] = useState([])\n  // Allows only one comment to be in editor mode at a time\n  const [editorOn, setEditorOn] = useState(false)\n  // Array of comment objects fetched from the API\n  const [comments, setComments] = useState([])\n\n  // Fetch all trail comments upon render\n  useEffect(() => {\n    getComments()},[])\n\n  // ---------- CODE FOR TYPING/POSTING NEW COMMENT ----------\n  \n  // Set state of commentEntry to whatever the form input is \n  const handleChange = (e) =>{\n    setCommentEntry(e.target.value)\n  }\n\n  // Only call POST function if comment isn't blank\n  const handleSubmit = () =>{\n    if (commentEntry === \"\") return\n    else addToComments()\n  }\n\n  // Fetch request to POST comment\n  const addToComments = () => {\n    fetch(\"/comments\", {\n      // JSON needs to include comment string, trail id, and user name\n      body: JSON.stringify({post: commentEntry, trail_id: props.trail_id, user_name: props.user_name, trail_name: props.trail_name}),\n      headers:{\n        \"Content-Type\": \"application/json\"\n      },\n      method: \"POST\"\n    })\n    .then(response => {\n      if (response.ok) {\n        // If post successful, clear new comment form\n        setCommentEntry(\"\")\n        // Refetch comments upon adding new comment\n        getComments()\n      }\n    })\n    .catch(error => {\n      console.log(\"error:\",error)\n    })\n  }\n\n  // ---------- CODE FOR EDITING/UPDATING EXISTING COMMENT ----------\n\n  // Upon clicking the Edit button, do the following:\n  const handleEditClick = (id,body) => {\n    // Check that the particular comment's ID is not in the \"editArray\" and editor mode is not open elsewhere\n    if (!editArray.includes(id) && !editorOn) {\n      // Set editor mode to true to prevent other editors from opening\n      setEditorOn(true)\n      // Add comment ID to array\n      setEditArray([...editArray, id])\n      // Set the comment edit entry to the comment text\n      setCommentEditEntry(body)\n    } // \n      else if (editArray.includes(id) && editorOn) {\n      setEditorOn(false)\n      let temp = editArray.filter(num=> num !== id)\n      setEditArray(temp)\n      setCommentEditEntry(\"\")\n    }\n  }\n\n  // Set state of commentEditEntry to \n  const handleChangeEdit = e => {\n    setCommentEditEntry(e.target.value)\n  }\n\n  //\n  const updateComment = (id, trailId) => {\n    fetch(`/comments/${id}`, {\n      body: JSON.stringify({post: commentEditEntry, trail_id: trailId, user_name: props.user_name, trail_name: props.trail_name}),\n      headers:{\n        \"Content-Type\": \"application/json\"\n      },\n      method: \"PATCH\"\n    })\n    .then(response => {\n      if (response.ok) {\n        let temp = editArray.filter(num=> num !== id)\n        setEditArray(temp)\n        setEditorOn(false)\n        getComments()\n      }\n    })\n    .catch(error => {\n      console.log(\"error:\",error)\n    })\n  }\n\n  // ---------- CODE FOR FETCHIING ALL TRAIL COMMENTS ----------\n\n  async function getComments() {\n    try {\n      let response = await fetch('/comments')\n      let data = await response.json()\n      \n      if(response.ok) {\n        //check the console to make sure we have all the trails\n        let sortedData = data.filter(trail => {\n          return trail.trail_id == props.trail_id\n        })\n        .sort((a,b)=>{\n          if (a.updated_at === b.updated_at) return 0\n          else if (a.updated_at > b.updated_at) return -1\n          else return 1\n        })\n        //populate the newTrails state array with data\n        setComments(sortedData)\n        console.log(\"sorted comments data:\", sortedData)\n      }\n    } catch (err) {\n      console.log(err)\n    }\n  }\n  \n  // ---------- CODE FOR DELETING COMMENT ----------\n\n  const deleteComment = (id) => {\n    fetch(`/comments/${id}`, {\n      headers:{\n        \"Content-Type\": \"application/json\"\n      },\n      method: \"DELETE\"\n    })\n    .then(response => {\n      if (response.ok) {\n        getComments()\n      }\n    })\n  }\n\n  return ( \n  \n  <Container className=\"comment-index-container\">\n      {props.logged_in &&\n        <CommentNew \n          handleSubmit={handleSubmit}\n          commentEntry={commentEntry}\n          handleChange={handleChange}\n        />\n      }\n      <CommentList \n        comments={comments}\n        commentEditEntry={commentEditEntry}\n        editArray={editArray}\n        user_id={props.user_id}\n        updateComment={updateComment}\n        handleChangeEdit={handleChangeEdit}\n        handleEditClick={handleEditClick}\n        deleteComment={deleteComment}\n      />\n  </Container>\n  )\n}\n\nexport default Comments"]},"metadata":{},"sourceType":"module"}