{"ast":null,"code":"import t from \"leaflet\";\n\nfunction e() {\n  return (e = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n\n      for (var r in n) {\n        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n      }\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction n(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction r(t, e) {\n  return (r = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction o() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction i(t, e, n) {\n  return (i = o() ? Reflect.construct : function (t, e, n) {\n    var o = [null];\n    o.push.apply(o, e);\n    var i = new (Function.bind.apply(t, o))();\n    return n && r(i, n.prototype), i;\n  }).apply(null, arguments);\n}\n\nfunction s(t, e, n, r) {\n  void 0 === e && (e = \"\"), void 0 === r && (r = {});\n  var o = document.createElement(t);\n  return e && (o.className = e), Object.keys(r).forEach(function (t) {\n    if (\"function\" == typeof r[t]) {\n      var e = 0 === t.indexOf(\"on\") ? t.substr(2).toLowerCase() : t;\n      o.addEventListener(e, r[t]);\n    } else \"html\" === t ? o.innerHTML = r[t] : \"text\" === t ? o.innerText = r[t] : o.setAttribute(t, r[t]);\n  }), n && n.appendChild(o), o;\n}\n\nfunction a(t) {\n  t.preventDefault(), t.stopPropagation();\n}\n\nvar u = function u() {\n  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {\n    e[n] = arguments[n];\n  }\n\n  return e.filter(Boolean).join(\" \").trim();\n};\n\nfunction c(t, e) {\n  t && t.classList && (Array.isArray(e) ? e : [e]).forEach(function (e) {\n    t.classList.contains(e) || t.classList.add(e);\n  });\n}\n\nfunction l(t, e) {\n  t && t.classList && (Array.isArray(e) ? e : [e]).forEach(function (e) {\n    t.classList.contains(e) && t.classList.remove(e);\n  });\n}\n\nvar h,\n    p = 13,\n    f = 40,\n    d = 38,\n    m = [p, 27, f, d, 37, 39],\n    v = function () {\n  function t(t) {\n    var e = this,\n        n = t.handleSubmit,\n        r = t.searchLabel,\n        o = t.classNames,\n        i = void 0 === o ? {} : o;\n    this.hasError = !1, this.container = s(\"div\", u(\"geosearch\", i.container)), this.form = s(\"form\", [\"\", i.form].join(\" \"), this.container, {\n      autocomplete: \"none\",\n      onClick: a,\n      onDblClick: a,\n      touchStart: a,\n      touchEnd: a\n    }), this.input = s(\"input\", [\"glass\", i.input].join(\" \"), this.form, {\n      type: \"text\",\n      placeholder: r || \"search\",\n      onInput: this.onInput,\n      onKeyUp: function onKeyUp(t) {\n        return e.onKeyUp(t);\n      },\n      onKeyPress: function onKeyPress(t) {\n        return e.onKeyPress(t);\n      },\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onClick: function onClick() {\n        e.input.focus(), e.input.dispatchEvent(new Event(\"focus\"));\n      }\n    }), this.handleSubmit = n;\n  }\n\n  var e = t.prototype;\n  return e.onFocus = function () {\n    c(this.form, \"active\");\n  }, e.onBlur = function () {\n    l(this.form, \"active\");\n  }, e.onSubmit = function (t) {\n    try {\n      var e = this;\n      return a(t), l(n = e.container, \"error\"), c(n, \"pending\"), Promise.resolve(e.handleSubmit({\n        query: e.input.value\n      })).then(function () {\n        l(e.container, \"pending\");\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n\n    var n;\n  }, e.onInput = function () {\n    this.hasError && (l(this.container, \"error\"), this.hasError = !1);\n  }, e.onKeyUp = function (t) {\n    27 === t.keyCode && (l(this.container, [\"pending\", \"active\"]), this.input.value = \"\", document.body.focus(), document.body.blur());\n  }, e.onKeyPress = function (t) {\n    t.keyCode === p && this.onSubmit(t);\n  }, e.setQuery = function (t) {\n    this.input.value = t;\n  }, t;\n}(),\n    y = function () {\n  function t(t) {\n    var e = this,\n        n = t.handleClick,\n        r = t.classNames,\n        o = void 0 === r ? {} : r;\n    this.selected = -1, this.results = [], this.onClick = function (t) {\n      if (\"function\" == typeof e.handleClick) {\n        var n = t.target;\n\n        if (n && e.container.contains(n) && n.hasAttribute(\"data-key\")) {\n          var r = Number(n.getAttribute(\"data-key\"));\n          e.handleClick({\n            result: e.results[r]\n          });\n        }\n      }\n    }, this.handleClick = n, this.container = s(\"div\", u(\"results\", o.container)), this.container.addEventListener(\"click\", this.onClick, !0), this.resultItem = s(\"div\", u(o.item));\n  }\n\n  var e = t.prototype;\n  return e.render = function (t) {\n    var e = this;\n    void 0 === t && (t = []), this.clear(), t.forEach(function (t, n) {\n      var r = e.resultItem.cloneNode(!0);\n      r.setAttribute(\"data-key\", \"\" + n), r.innerHTML = t.label, e.container.appendChild(r);\n    }), t.length > 0 && (c(this.container.parentElement, \"open\"), c(this.container, \"active\")), this.results = t;\n  }, e.select = function (t) {\n    return Array.from(this.container.children).forEach(function (e, n) {\n      return n === t ? c(e, \"active\") : l(e, \"active\");\n    }), this.selected = t, this.results[t];\n  }, e.count = function () {\n    return this.results ? this.results.length : 0;\n  }, e.clear = function () {\n    for (this.selected = -1; this.container.lastChild;) {\n      this.container.removeChild(this.container.lastChild);\n    }\n\n    l(this.container.parentElement, \"open\"), l(this.container, \"active\");\n  }, t;\n}(),\n    g = {\n  position: \"topleft\",\n  style: \"button\",\n  showMarker: !0,\n  showPopup: !1,\n  popupFormat: function popupFormat(t) {\n    return \"\" + t.result.label;\n  },\n  marker: {\n    icon: t && t.Icon ? new t.Icon.Default() : void 0,\n    draggable: !1\n  },\n  maxMarkers: 1,\n  maxSuggestions: 5,\n  retainZoomLevel: !1,\n  animateZoom: !0,\n  searchLabel: \"Enter address\",\n  notFoundMessage: \"Sorry, that address could not be found.\",\n  messageHideDelay: 3e3,\n  zoomLevel: 18,\n  classNames: {\n    container: \"leaflet-bar leaflet-control leaflet-control-geosearch\",\n    button: \"leaflet-bar-part leaflet-bar-part-single\",\n    resetButton: \"reset\",\n    msgbox: \"leaflet-bar message\",\n    form: \"\",\n    input: \"\"\n  },\n  autoComplete: !0,\n  autoCompleteDelay: 250,\n  autoClose: !1,\n  keepResult: !1\n},\n    b = \"Leaflet must be loaded before instantiating the GeoSearch control\",\n    E = {\n  options: e({}, g),\n  classNames: e({}, g.classNames),\n  initialize: function initialize(n) {\n    var r,\n        o,\n        i,\n        a,\n        u = this;\n    if (!t) throw new Error(b);\n    if (!n.provider) throw new Error(\"Provider is missing from options\");\n    this.options = e({}, this.options, {}, n), this.classNames = e({}, this.classNames, {}, n.classNames), this.markers = new t.FeatureGroup(), this.classNames.container += \" leaflet-geosearch-\" + this.options.style, this.searchElement = new v({\n      searchLabel: this.options.searchLabel,\n      classNames: {\n        container: this.classNames.container,\n        form: this.classNames.form,\n        input: this.classNames.input\n      },\n      handleSubmit: function handleSubmit(t) {\n        return u.onSubmit(t);\n      }\n    }), this.button = s(\"a\", this.classNames.button, this.searchElement.container, {\n      title: this.options.searchLabel,\n      href: \"#\",\n      onClick: function onClick(t) {\n        return u.onClick(t);\n      }\n    }), t.DomEvent.disableClickPropagation(this.button), this.resetButton = s(\"a\", this.classNames.resetButton, this.searchElement.form, {\n      text: \"Ã—\",\n      href: \"#\",\n      onClick: function onClick() {\n        return u.clearResults(null, !0);\n      }\n    }), t.DomEvent.disableClickPropagation(this.resetButton), this.options.autoComplete && (this.resultList = new y({\n      handleClick: function handleClick(t) {\n        var e = t.result;\n        u.searchElement.input.value = e.label, u.onSubmit({\n          query: e.label,\n          data: e\n        });\n      }\n    }), this.searchElement.form.appendChild(this.resultList.container), this.searchElement.input.addEventListener(\"keyup\", (r = function r(t) {\n      return u.autoSearch(t);\n    }, void 0 === (o = this.options.autoCompleteDelay) && (o = 250), void 0 === i && (i = !1), function () {\n      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {\n        e[n] = arguments[n];\n      }\n\n      a && clearTimeout(a), a = setTimeout(function () {\n        a = null, i || r.apply(void 0, e);\n      }, o), i && !a && r.apply(void 0, e);\n    }), !0), this.searchElement.input.addEventListener(\"keydown\", function (t) {\n      return u.selectResult(t);\n    }, !0), this.searchElement.input.addEventListener(\"keydown\", function (t) {\n      return u.clearResults(t, !0);\n    }, !0)), this.searchElement.form.addEventListener(\"click\", function (t) {\n      t.preventDefault();\n    }, !1);\n  },\n  onAdd: function onAdd(e) {\n    var n = this.options,\n        r = n.showMarker,\n        o = n.style;\n\n    if (this.map = e, r && this.markers.addTo(e), \"bar\" === o) {\n      var i = e.getContainer().querySelector(\".leaflet-control-container\");\n      this.container = s(\"div\", \"leaflet-control-geosearch leaflet-geosearch-bar\"), this.container.appendChild(this.searchElement.form), i.appendChild(this.container);\n    }\n\n    return t.DomEvent.disableClickPropagation(this.searchElement.form), this.searchElement.container;\n  },\n  onRemove: function onRemove() {\n    var t;\n    return null == (t = this.container) || t.remove(), this;\n  },\n  onClick: function onClick(t) {\n    t.preventDefault(), t.stopPropagation();\n    var e = this.searchElement,\n        n = e.container,\n        r = e.input;\n    n.classList.contains(\"active\") ? (l(n, \"active\"), this.clearResults()) : (c(n, \"active\"), r.focus());\n  },\n  selectResult: function selectResult(t) {\n    if (-1 !== [p, f, d].indexOf(t.keyCode)) if (t.preventDefault(), t.keyCode !== p) {\n      var e = this.resultList.count() - 1;\n\n      if (!(e < 0)) {\n        var n = this.resultList.selected,\n            r = t.keyCode === f ? n + 1 : n - 1,\n            o = this.resultList.select(r < 0 ? e : r > e ? 0 : r);\n        this.searchElement.input.value = o.label;\n      }\n    } else {\n      var i = this.resultList.select(this.resultList.selected);\n      this.onSubmit({\n        query: this.searchElement.input.value,\n        data: i\n      });\n    }\n  },\n  clearResults: function clearResults(t, e) {\n    if (void 0 === e && (e = !1), !t || 27 === t.keyCode) {\n      var n = this.options,\n          r = n.autoComplete;\n      !e && n.keepResult || (this.searchElement.input.value = \"\", this.markers.clearLayers()), r && this.resultList.clear();\n    }\n  },\n  autoSearch: function autoSearch(t) {\n    try {\n      var e = this;\n      if (m.indexOf(t.keyCode) > -1) return Promise.resolve();\n\n      var n = t.target.value,\n          r = e.options.provider,\n          o = function () {\n        if (n.length) return Promise.resolve(r.search({\n          query: n\n        })).then(function (t) {\n          t = t.slice(0, e.options.maxSuggestions), e.resultList.render(t);\n        });\n        e.resultList.clear();\n      }();\n\n      return Promise.resolve(o && o.then ? o.then(function () {}) : void 0);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  },\n  onSubmit: function onSubmit(t) {\n    try {\n      var e = this;\n      return Promise.resolve(e.options.provider.search(t)).then(function (n) {\n        n && n.length > 0 && e.showResult(n[0], t);\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  },\n  showResult: function showResult(t, e) {\n    var n = this.options.autoClose,\n        r = Object.keys(this.markers._layers);\n    r.length >= this.options.maxMarkers && this.markers.removeLayer(r[0]);\n    var o = this.addMarker(t, e);\n    this.centerMap(t), this.map.fireEvent(\"geosearch/showlocation\", {\n      location: t,\n      marker: o\n    }), n && this.closeResults();\n  },\n  closeResults: function closeResults() {\n    var t = this.searchElement.container;\n    t.classList.contains(\"active\") && l(t, \"active\"), this.clearResults();\n  },\n  addMarker: function addMarker(e, n) {\n    var r = this,\n        o = this.options,\n        i = o.marker,\n        s = o.showPopup,\n        a = o.popupFormat,\n        u = new t.Marker([e.y, e.x], i),\n        c = e.label;\n    return \"function\" == typeof a && (c = a({\n      query: n,\n      result: e\n    })), u.bindPopup(c), this.markers.addLayer(u), s && u.openPopup(), i.draggable && u.on(\"dragend\", function (t) {\n      r.map.fireEvent(\"geosearch/marker/dragend\", {\n        location: u.getLatLng(),\n        event: t\n      });\n    }), u;\n  },\n  centerMap: function centerMap(e) {\n    var n = this.options,\n        r = n.retainZoomLevel,\n        o = n.animateZoom,\n        i = e.bounds ? new t.LatLngBounds(e.bounds) : new t.LatLng(e.y, e.x).toBounds(10),\n        s = i.isValid() ? i : this.markers.getBounds();\n    !r && i.isValid() ? this.map.fitBounds(s, {\n      animate: o\n    }) : this.map.setView(s.getCenter(), this.getZoom(), {\n      animate: o\n    });\n  },\n  getZoom: function getZoom() {\n    var t = this.options,\n        e = t.zoomLevel;\n    return t.retainZoomLevel ? this.map.getZoom() : e;\n  }\n};\n\nfunction L() {\n  if (!t) throw new Error(b);\n\n  for (var e = t.Control.extend(E), n = arguments.length, r = new Array(n), o = 0; o < n; o++) {\n    r[o] = arguments[o];\n  }\n\n  return i(e, r);\n}\n\n!function (t) {\n  t[t.SEARCH = 0] = \"SEARCH\", t[t.REVERSE = 1] = \"REVERSE\";\n}(h || (h = {}));\n\nvar k = function () {\n  function t(t) {\n    void 0 === t && (t = {}), this.options = t;\n  }\n\n  var n = t.prototype;\n  return n.getParamString = function (t) {\n    void 0 === t && (t = {});\n    var n = e({}, this.options.params, {}, t);\n    return Object.keys(n).map(function (t) {\n      return encodeURIComponent(t) + \"=\" + encodeURIComponent(n[t]);\n    }).join(\"&\");\n  }, n.getUrl = function (t, e) {\n    return t + \"?\" + this.getParamString(e);\n  }, n.search = function (t) {\n    try {\n      var e = this,\n          n = e.endpoint({\n        query: t.query,\n        type: h.SEARCH\n      });\n      return Promise.resolve(fetch(n)).then(function (t) {\n        return Promise.resolve(t.json()).then(function (t) {\n          return e.parse({\n            data: t\n          });\n        });\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, t;\n}(),\n    w = function (t) {\n  function r() {\n    return t.apply(this, arguments) || this;\n  }\n\n  n(r, t);\n  var o = r.prototype;\n  return o.endpoint = function () {\n    return \"https://places-dsn.algolia.net/1/places/query\";\n  }, o.findBestMatchLevelIndex = function (t) {\n    var e = t.find(function (t) {\n      return \"full\" === t.matchLevel;\n    }) || t.find(function (t) {\n      return \"partial\" === t.matchLevel;\n    });\n    return e ? t.indexOf(e) : 0;\n  }, o.getLabel = function (t) {\n    var e, n, r, o;\n    return [null == (e = t.locale_names) ? void 0 : e[\"default\"][this.findBestMatchLevelIndex(t._highlightResult.locale_names[\"default\"])], null == (n = t.city) ? void 0 : n[\"default\"][this.findBestMatchLevelIndex(t._highlightResult.city[\"default\"])], t.administrative[this.findBestMatchLevelIndex(t._highlightResult.administrative)], null == (r = t.postcode) ? void 0 : r[this.findBestMatchLevelIndex(t._highlightResult.postcode)], null == (o = t.country) ? void 0 : o[\"default\"]].filter(Boolean).join(\", \");\n  }, o.parse = function (t) {\n    var e = this;\n    return t.data.hits.map(function (t) {\n      return {\n        x: t._geoloc.lng,\n        y: t._geoloc.lat,\n        label: e.getLabel(t),\n        bounds: null,\n        raw: t\n      };\n    });\n  }, o.search = function (t) {\n    var n = t.query;\n\n    try {\n      var r = this,\n          o = \"string\" == typeof n ? {\n        query: n\n      } : n;\n      return Promise.resolve(fetch(r.endpoint(), {\n        method: \"POST\",\n        body: JSON.stringify(e({}, r.options.params, {}, o))\n      })).then(function (t) {\n        return Promise.resolve(t.json()).then(function (t) {\n          return r.parse({\n            data: t\n          });\n        });\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r;\n}(k),\n    C = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://dev.virtualearth.net/REST/v1/Locations\", e;\n  }\n\n  n(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        n = \"string\" == typeof e ? {\n      q: e\n    } : e;\n    return n.jsonp = t.jsonp, this.getUrl(this.searchUrl, n);\n  }, r.parse = function (t) {\n    return 0 === t.data.resourceSets.length ? [] : t.data.resourceSets[0].resources.map(function (t) {\n      return {\n        x: t.point.coordinates[1],\n        y: t.point.coordinates[0],\n        label: t.address.formattedAddress,\n        bounds: [[t.bbox[0], t.bbox[1]], [t.bbox[2], t.bbox[3]]],\n        raw: t\n      };\n    });\n  }, r.search = function (t) {\n    var e,\n        n,\n        r,\n        o = t.query;\n\n    try {\n      var i = this,\n          a = \"BING_JSONP_CB_\" + Date.now();\n      return Promise.resolve((e = i.endpoint({\n        query: o,\n        jsonp: a\n      }), n = a, r = s(\"script\", null, document.body), r.setAttribute(\"type\", \"text/javascript\"), new Promise(function (t) {\n        window[n] = function (e) {\n          r.remove(), delete window[n], t(e);\n        }, r.setAttribute(\"src\", e);\n      }))).then(function (t) {\n        return i.parse({\n          data: t\n        });\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}(k),\n    x = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/find\", e;\n  }\n\n  n(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        n = \"string\" == typeof e ? {\n      text: e\n    } : e;\n    return n.f = \"json\", this.getUrl(this.searchUrl, n);\n  }, r.parse = function (t) {\n    return t.data.locations.map(function (t) {\n      return {\n        x: t.feature.geometry.x,\n        y: t.feature.geometry.y,\n        label: t.name,\n        bounds: [[t.extent.ymin, t.extent.xmin], [t.extent.ymax, t.extent.xmax]],\n        raw: t\n      };\n    });\n  }, e;\n}(k),\n    P = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://maps.googleapis.com/maps/api/geocode/json\", e;\n  }\n\n  n(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query;\n    return this.getUrl(this.searchUrl, \"string\" == typeof e ? {\n      address: e\n    } : e);\n  }, r.parse = function (t) {\n    return t.data.results.map(function (t) {\n      return {\n        x: t.geometry.location.lng,\n        y: t.geometry.location.lat,\n        label: t.formatted_address,\n        bounds: [[t.geometry.viewport.southwest.lat, t.geometry.viewport.southwest.lng], [t.geometry.viewport.northeast.lat, t.geometry.viewport.northeast.lng]],\n        raw: t\n      };\n    });\n  }, e;\n}(k),\n    R = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://geocode.search.hereapi.com/v1/geocode\", e;\n  }\n\n  n(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query;\n    return this.getUrl(this.searchUrl, \"string\" == typeof e ? {\n      q: e\n    } : e);\n  }, r.parse = function (t) {\n    return t.data.items.map(function (t) {\n      return {\n        x: t.position.lng,\n        y: t.position.lat,\n        label: t.address.label,\n        bounds: null,\n        raw: t\n      };\n    });\n  }, e;\n}(k),\n    S = function (t) {\n  function e(e) {\n    var n;\n    void 0 === e && (e = {});\n    var r = \"https://nominatim.openstreetmap.org\";\n    return (n = t.call(this, e) || this).searchUrl = e.searchUrl || r + \"/search\", n.reverseUrl = e.reverseUrl || r + \"/reverse\", n;\n  }\n\n  n(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        n = t.type,\n        r = \"string\" == typeof e ? {\n      q: e\n    } : e;\n\n    switch (r.format = \"json\", n) {\n      case h.REVERSE:\n        return this.getUrl(this.reverseUrl, r);\n\n      default:\n        return this.getUrl(this.searchUrl, r);\n    }\n  }, r.parse = function (t) {\n    return (Array.isArray(t.data) ? t.data : [t.data]).map(function (t) {\n      return {\n        x: Number(t.lon),\n        y: Number(t.lat),\n        label: t.display_name,\n        bounds: [[parseFloat(t.boundingbox[0]), parseFloat(t.boundingbox[2])], [parseFloat(t.boundingbox[1]), parseFloat(t.boundingbox[3])]],\n        raw: t\n      };\n    });\n  }, e;\n}(k),\n    U = function (t) {\n  function r(n) {\n    return t.call(this, e({}, n, {\n      searchUrl: \"https://locationiq.org/v1/search.php\",\n      reverseUrl: \"https://locationiq.org/v1/reverse.php\"\n    })) || this;\n  }\n\n  return n(r, t), r;\n}(S),\n    j = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).searchUrl = \"https://api.opencagedata.com/geocode/v1/json\", e;\n  }\n\n  n(e, t);\n  var r = e.prototype;\n  return r.endpoint = function (t) {\n    var e = t.query,\n        n = \"string\" == typeof e ? {\n      q: e\n    } : e;\n    return n.format = \"json\", this.getUrl(this.searchUrl, n);\n  }, r.parse = function (t) {\n    return t.data.results.map(function (t) {\n      return {\n        x: t.geometry.lng,\n        y: t.geometry.lat,\n        label: t.formatted,\n        bounds: [[t.bounds.southwest.lat, t.bounds.southwest.lng], [t.bounds.northeast.lat, t.bounds.northeast.lng]],\n        raw: t\n      };\n    });\n  }, r.search = function (e) {\n    try {\n      return Promise.resolve(e.query.length < 2 ? [] : t.prototype.search.call(this, e));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}(k);\n\nexport { w as AlgoliaProvider, C as BingProvider, x as EsriProvider, L as GeoSearchControl, P as GoogleProvider, R as HereProvider, k as JsonProvider, U as LocationIQProvider, j as OpenCageProvider, S as OpenStreetMapProvider, L as SearchControl, v as SearchElement };","map":null,"metadata":{},"sourceType":"module"}